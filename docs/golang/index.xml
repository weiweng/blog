<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Golangs on weiweng的博客</title>
    <link>https://weiweng.github.io/blog/golang/</link>
    <description>Recent content in Golangs on weiweng的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sat, 17 Dec 2022 11:18:00 +0800</lastBuildDate><atom:link href="https://weiweng.github.io/blog/golang/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>分布式事务管理DTM</title>
      <link>https://weiweng.github.io/blog/golang/2022-12-17-dmt/</link>
      <pubDate>Sat, 17 Dec 2022 11:18:00 +0800</pubDate>
      
      <guid>https://weiweng.github.io/blog/golang/2022-12-17-dmt/</guid>
      <description>学习新东西，先是灵魂3问————是什么、解决什么问题、有什么好处？ 首先，DTM是什么？DTM是一款开源的分布式事务管理器，解决跨数据库、跨服务、跨语言栈更新数据</description>
    </item>
    
    <item>
      <title>Golang|interface</title>
      <link>https://weiweng.github.io/blog/golang/2020-08-31-interface%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</link>
      <pubDate>Mon, 31 Aug 2020 09:26:00 +0800</pubDate>
      
      <guid>https://weiweng.github.io/blog/golang/2020-08-31-interface%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</guid>
      <description>interface 接口类型 接口是一种抽象类型，它没有暴露所含数据的布局或者内部结构，当然也没有哪些数据的基本操作，所提供的仅仅是一些方法。当你拿到一个接口类型的变量，你无从知道</description>
    </item>
    
    <item>
      <title>Golang|go-snowflake</title>
      <link>https://weiweng.github.io/blog/golang/2020-07-11-golanggo-snowflake/</link>
      <pubDate>Sat, 11 Jul 2020 03:06:00 +0800</pubDate>
      
      <guid>https://weiweng.github.io/blog/golang/2020-07-11-golanggo-snowflake/</guid>
      <description>go-snowflake 在单机系统中我们会使用自增id作为数据的唯一id，自增id在数据库中有利于排序和索引，但是在分布式系统中如果还是利用数据库的自增id会引起冲突，自增id非常容</description>
    </item>
    
    <item>
      <title>Golang|defer</title>
      <link>https://weiweng.github.io/blog/golang/2020-07-11-defer/</link>
      <pubDate>Sat, 11 Jul 2020 02:43:00 +0800</pubDate>
      
      <guid>https://weiweng.github.io/blog/golang/2020-07-11-defer/</guid>
      <description>defer的原理</description>
    </item>
    
    <item>
      <title>Golang|使用注意</title>
      <link>https://weiweng.github.io/blog/golang/2020-06-18-Golang%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E7%82%B9/</link>
      <pubDate>Thu, 18 Jun 2020 12:20:00 +0800</pubDate>
      
      <guid>https://weiweng.github.io/blog/golang/2020-06-18-Golang%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E7%82%B9/</guid>
      <description>select break go中使用for select 结构，select的break只能跳出break，不能跳出for循环 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 package</description>
    </item>
    
    <item>
      <title>Golang|test</title>
      <link>https://weiweng.github.io/blog/golang/2020-04-30-go-test%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Thu, 30 Apr 2020 06:56:00 +0800</pubDate>
      
      <guid>https://weiweng.github.io/blog/golang/2020-04-30-go-test%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</guid>
      <description>go test测试包 go test {测试文件所在包目录} 当前目录下单测指定测试函数 $ go test -v -test.run {函数名xxx} cover信息采集用例 go test -coverprofile cp.out- go tool cover -html=cp.out 其他信息采集 -blockprofilerate n：gorou</description>
    </item>
    
    <item>
      <title>Golang|panic、recover</title>
      <link>https://weiweng.github.io/blog/golang/2020-04-18-panicrecover/</link>
      <pubDate>Sat, 18 Apr 2020 03:02:00 +0800</pubDate>
      
      <guid>https://weiweng.github.io/blog/golang/2020-04-18-panicrecover/</guid>
      <description>panic 结构体 panic 关键字在 Go 语言的源代码是由数据结构runtime._panic表示的。每当我们调用 panic 都会创建一个如下所示的数据结构存储相关信息： 1 2 3 4 5 6 7 8 9 10 11</description>
    </item>
    
    <item>
      <title>Golang|垃圾回收</title>
      <link>https://weiweng.github.io/blog/golang/2020-04-07-Golang%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</link>
      <pubDate>Tue, 07 Apr 2020 10:56:00 +0800</pubDate>
      
      <guid>https://weiweng.github.io/blog/golang/2020-04-07-Golang%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</guid>
      <description>垃圾回收 垃圾回收(Garbage Collection，简称GC)是编程语言中提供的内存管理功能。 通过引入了语言层面的自动内存管理，也就是语言的使用者只用关注内存</description>
    </item>
    
    <item>
      <title>Golang|context</title>
      <link>https://weiweng.github.io/blog/golang/2020-03-15-context%E4%BD%BF%E7%94%A8%E5%92%8C%E5%88%86%E6%9E%90/</link>
      <pubDate>Sun, 15 Mar 2020 06:16:00 +0800</pubDate>
      
      <guid>https://weiweng.github.io/blog/golang/2020-03-15-context%E4%BD%BF%E7%94%A8%E5%92%8C%E5%88%86%E6%9E%90/</guid>
      <description>context意义 Go 中的 context 包在与 API 和慢处理交互时可以派上用场，特别是在生产级的 Web 服务中。在这些场景中，您可能想要通知所有的 goroutine 停止运行并返回。 context使用 c</description>
    </item>
    
    <item>
      <title>Golang|channel</title>
      <link>https://weiweng.github.io/blog/golang/2020-03-15-channel%E5%88%86%E6%9E%90/</link>
      <pubDate>Sun, 15 Mar 2020 06:15:00 +0800</pubDate>
      
      <guid>https://weiweng.github.io/blog/golang/2020-03-15-channel%E5%88%86%E6%9E%90/</guid>
      <description>channel结构体 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 type hchan struct { qcount uint //大小 dataqsiz uint //有缓存的队列大小 buf unsafe.Pointer //有缓存的循环队列指针 elemsize uint16 closed uint32 elemtype *_type //类型 sendx uint //有缓存</description>
    </item>
    
    <item>
      <title>golang|内存分配</title>
      <link>https://weiweng.github.io/blog/golang/2020-03-15-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</link>
      <pubDate>Sun, 15 Mar 2020 06:00:00 +0800</pubDate>
      
      <guid>https://weiweng.github.io/blog/golang/2020-03-15-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</guid>
      <description>内存分配 GO语言内存管理子系统主要由两部分组成：内存分配器和垃圾回收器（gc）。内存分配器主要解决小对象的分配管理和多线程的内存分配问题。 Golang运行时的内</description>
    </item>
    
    <item>
      <title>Golang|MPG</title>
      <link>https://weiweng.github.io/blog/golang/2020-03-15-MPG%E5%88%86%E6%9E%90/</link>
      <pubDate>Sun, 15 Mar 2020 05:57:00 +0800</pubDate>
      
      <guid>https://weiweng.github.io/blog/golang/2020-03-15-MPG%E5%88%86%E6%9E%90/</guid>
      <description>并行和并发 并发(concurrency) 两个或两个以上的任务在一段时间内被执行。例如跑步的时候，停下来系鞋带 并行(parallelism) 两个或两个以上的任务在</description>
    </item>
    
    <item>
      <title>Golang|pprof</title>
      <link>https://weiweng.github.io/blog/golang/2020-03-15-Pprof/</link>
      <pubDate>Sun, 15 Mar 2020 05:53:00 +0800</pubDate>
      
      <guid>https://weiweng.github.io/blog/golang/2020-03-15-Pprof/</guid>
      <description>pprof的基本安装和使用方法</description>
    </item>
    
    <item>
      <title>golang|FileServer</title>
      <link>https://weiweng.github.io/blog/golang/2020-03-15-FileServer/</link>
      <pubDate>Sun, 15 Mar 2020 05:52:00 +0800</pubDate>
      
      <guid>https://weiweng.github.io/blog/golang/2020-03-15-FileServer/</guid>
      <description>FileServer</description>
    </item>
    
    <item>
      <title>golang|基础笔记</title>
      <link>https://weiweng.github.io/blog/golang/2020-03-15-%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sun, 15 Mar 2020 05:51:00 +0800</pubDate>
      
      <guid>https://weiweng.github.io/blog/golang/2020-03-15-%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/</guid>
      <description>go课程 本文阅读课程来源见此go系列教程 变量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 //声明方式一 //var name type var age int age = 25 //声明并初始化 var age int = 25 //让go类型推</description>
    </item>
    
    <item>
      <title>Golang|map</title>
      <link>https://weiweng.github.io/blog/golang/2020-03-13-map/</link>
      <pubDate>Fri, 13 Mar 2020 06:38:00 +0800</pubDate>
      
      <guid>https://weiweng.github.io/blog/golang/2020-03-13-map/</guid>
      <description>map 由&amp;lt;key,value&amp;gt;对组成的抽象数据结构，并且同一个key只出现一次 实现对比 方法 | hash | 搜索树 -|-|- 复杂度 | O(1) | O(logN) 顺序 | 乱序 | 有序 痛点 | 碰撞问题 | 平</description>
    </item>
    
  </channel>
</rss>
