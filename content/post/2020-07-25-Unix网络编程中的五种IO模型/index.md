+++
title="Unix网络编程中的五种IO模型"
tags=["linux","io"]
categories=["linux"]
date="2020-07-25T10:51:00+08:00"
summary = 'Unix网络编程中的五种IO模型'
toc=false
+++

**Unix网络编程中的五种IO模型**
------------------------------

-	blocking IO - 阻塞IO
-	nonblocking IO - 非阻塞IO
-	IO multiplexing - IO多路复用
-	asynchronous IO - 异步IO
-	signal driven IO - 信号驱动IO

**网络io基本流程**
------------------

先说明一下IO发生时涉及到的对象和步骤，对于一个network IO，它会涉及到两个阶段

-	**阶段1 wait for data 等待数据准备**
-	**阶段2 copy data from kernel to user 将数据从内核拷贝到用户进程中**

阻塞io
------

在linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概如下图: ![阻塞io](https://img2020.cnblogs.com/blog/1780187/202007/1780187-20200725183946983-318093315.jpg)

当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据。对于network IO来说，很多时候数据在一开始还没有到达（比如，还没有收到一个完整的UDP包），这个时候kernel就要等待足够的数据到来。而在用户进程这边，整个进程会被阻塞。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。

非阻塞io
--------

![非阻塞io](https://img2020.cnblogs.com/blog/1780187/202007/1780187-20200725184006092-1092418259.jpg)

当用户进程发出recvfrom这个系统调用后，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个结果（no datagram ready）。从用户进程角度讲 ，它发起一个操作后，并没有等待，而是马上就得到了一个结果。用户进程得知数据还没有准备好后，它可以每隔一段时间再次发送recvfrom操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。

io多路复用
----------

![io多路复用](https://img2020.cnblogs.com/blog/1780187/202007/1780187-20200725184022227-841014882.jpg)

看起来它与blocking I/O很相似，两个阶段都阻塞。但它与blocking I/O的一个重要区别就是它可以等待多个数据报就绪（datagram ready），即可以处理多个连接。这里的select相当于一个“代理”，调用select以后进程会被select阻塞，这时候在内核空间内select会监听指定的多个datagram (如socket连接)，如果其中任意一个数据就绪了就返回。此时程序再进行数据读取操作，将数据拷贝至当前进程内。由于select可以监听多个socket，我们可以用它来处理多个连接。

在select模型中每个socket一般都设置成non-blocking，虽然等待数据阶段仍然是阻塞状态，但是它是被select调用阻塞的，而不是直接被I/O阻塞的。select底层通过轮询机制来判断每个socket读写是否就绪。

当然select也有一些缺点，比如底层轮询机制会增加开销、支持的文件描述符数量过少等。为此，Linux引入了epoll作为select的改进版本。

异步io
------

![异步io](https://img2020.cnblogs.com/blog/1780187/202007/1780187-20200725184033279-1274210643.jpg)

这里面的读取操作的语义与上面的几种模型都不同。这里的读取操作(aio_read)会通知内核进行读取操作并将数据拷贝至进程中，完事后通知进程整个操作全部完成（绑定一个回调函数处理数据）。读取操作会立刻返回，程序可以进行其它的操作，所有的读取、拷贝工作都由内核去做，做完以后通知进程，进程调用绑定的回调函数来处理数据。

总结
----

总结一下阻塞、非阻塞，同步和异步这两组概念。

### **阻塞和非阻塞**

-	阻塞调用会一直等待远程数据就绪再返回，即上面的阶段1会阻塞调用者，直到读取结束。
-	非阻塞无论在什么情况下都会立即返回，虽然非阻塞大部分时间不会被block，但是它仍要求进程不断地去主动询问kernel是否准备好数据，也需要进程主动地再次调用recvfrom来将数据拷贝到用户内存。

	### **同步和异步**

-	同步方法会一直阻塞进程，直到I/O操作结束，注意这里相当于上面的阶段1，阶段2都会阻塞调用者。其中 Blocking IO - 阻塞IO，Nonblocking IO - 非阻塞IO，IO multiplexing - IO多路复用，signal driven IO - 信号驱动IO 这四种IO都可以归类为同步IO。

-	异步方法不会阻塞调用者进程，即使是从内核空间的缓冲区将数据拷贝到进程中这一操作也不会阻塞进程，拷贝完毕后内核会通知进程数据拷贝结束。

参考
----

-	[一篇文章读懂阻塞，非阻塞，同步，异步](https://www.jianshu.com/p/b8203d46895c)

