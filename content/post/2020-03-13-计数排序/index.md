+++
title="计数排序"
date="2020-03-13T05:09:00+08:00"
categories=["算法&数据结构"]
summary = '计数排序'
toc=false
+++

总结
----

计数排序、基数排序、桶排序则属于非比较排序。非比较排序是通过确定每个元素之前，应该有多少个元素来排序。针对数组arr，计算arr[i]之前有多少个元素，则唯一确定了arr[i]在排序后数组中的位置。

非比较排序只要确定每个元素之前的已有的元素个数即可，所有一次遍历即可解决。算法时间复杂度O(n)。

非比较排序时间复杂度底，但由于非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。

计数排序
--------

计数排序需要占用大量空间，它仅适用于数据比较集中的情况。比如 [0~100]，[10000~19999] 这样的数据。

### 排序思想

每一个输入的元素arr[i]，确定小于 arr[i] 的元素个数。所以可以直接把 arr[i] 放到它输出数组中的位置上。假设有5个数小于 arr[i]，所以 arr[i] 应该放在数组的第6个位置上。

桶排序
------

桶排序可用于最大最小值相差较大的数据情况，比如[9012,19702,39867,68957,83556,102456]。但桶排序要求数据的分布必须均匀，否则可能导致数据都集中到一个桶中。比如[104,150,123,132,20000], 这种数据会导致前4个数都集中到同一个桶中。导致桶排序失效。

### 排序思想

桶排序的基本思想是：把数组 arr 划分为n个大小相同子区间（桶），每个子区间各自排序，最后合并。计数排序是桶排序的一种特殊情况，可以把计数排序当成每个桶里只有一个元素的情况。

1.	找出待排序数组中的最大值max、最小值min
2.	桶的数量为(max-min)/arr.length
3.	遍历数组 arr，计算每个元素 arr[i] 放的桶
4.	每个桶各自排序
5.	遍历桶数组，把排序好的元素放进输出数组

基数排序
--------

基数排序已经不再是一种常规的排序方式，它更多地像一种排序方法的应用，基数排序必须依赖于另外的排序方法。基数排序的总体思路就是将待排序数据拆分成多个关键字进行排序，也就是说，基数排序的实质是多关键字排序。

基数排序方法对任一子关键字排序时必须借助于另一种排序方法，而且这种排序方法必须是稳定的。对于多关键字拆分出来的子关键字，它们一定位于0-9这个可枚举的范围内，这个范围不大，因此用桶式排序效率非常好。对于多关键字排序来说，程序将待排数据拆分成多个子关键字后，对子关键字排序既可以使用桶式排序，也可以使用任何一种稳定的排序方法。

### 举例

举个例子，有一个整数序列，0, 123, 45, 386, 106，下面是排序过程：

1.	第一次排序，个位，000 123 045 386 106，无任何变化
2.	第二次排序，十位，000 106 123 045 386
3.	第三次排序，百位，000 045 106 123 386
4.	最终结果，0, 45, 106, 123, 386, 排序完成。

参考
----

1.	[关于计数排序、桶排序与基数排序的小结](https://www.cnblogs.com/protected/p/6603536.html)

