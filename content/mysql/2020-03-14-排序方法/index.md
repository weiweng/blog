+++
title="mysql|排序方法"
tags=["mysql","排序"]
categories=["mysql"]
date="2020-03-14T02:59:00+08:00"
summary = '排序方法'
toc=false
+++

全字段排序
----------

### 分析语句

`select city,name,age from t where city='XX' order by name limit 1000;`

### 排序流程

1.	初始化 `sort_buffer`，确定放入 name、city、age 这三个字段
2.	从索引 city 找到第一个满足 `city='XX'`条件的主键 id
3.	到主键 id 索引取出整行，取 name、city、age 三个字段的值，存入 `sort_buffer` 中
4.	从索引 city 取下一个记录的主键 id
5.	重复步骤 3、4 直到 city 的值不满足查询条件为止
6.	对 `sort_buffer` 中的数据按照字段 name 做快速排序
7.	按照排序结果取前 1000 行返回给客户端

上述分析中，需要对name排序，而排序的处理过程可能在内存中，也可能需要借助外部资源进行排序。

`sort_buffer_size`，就是 MySQL 为排序开辟的内存（sort_buffer）的大小。如果要排序的数据量小于 `sort_buffer_size`，排序就在内存中完成。但如果排序数据量太大，内存放不下，则不得不利用磁盘临时文件辅助排序。

rowid 排序
----------

在上面这个算法过程里面，只对原表的数据读了一遍，剩下的操作都是在 sort_buffer 和临时文件中执行的。但这个算法有一个问题，就是如果查询要返回的字段很多的话，那么 sort_buffer 里面要放的字段数太多，这样内存里能够同时放下的行数很少，要分成很多个临时文件，排序的性能会很差。

### 排序流程

1.	初始化 `sort_buffer`，确定放入两个字段，即 name 和 id
2.	从索引 city 找到第一个满足 city='杭州’条件的主键 id
3.	到主键 id 索引取出整行，取 name、id 这两个字段，存入 `sort_buffer` 中
4.	从索引 city 取下一个记录的主键 id
5.	重复步骤 3、4 直到不满足 city='杭州’条件为止
6.	对 `sort_buffer` 中的数据按照字段 name 进行排序
7.	遍历排序结果，取前 1000 行，并按照 id 的值回到原表中取出 city、name 和 age 三个字段返回给客户端

比较
----

如果 MySQL 实在是担心排序内存太小，会影响排序效率，才会采用 rowid 排序算法，这样排序过程中一次可以排序更多行，但是需要再回到原表去取数据。如果 MySQL 认为内存足够大，会优先选择全字段排序，把需要的字段都放到 sort_buffer 中，这样排序后就会直接从内存里面返回查询结果了，不用再回到原表去取数据。

这也就体现了 MySQL 的一个设计思想：如果内存够，就要多利用内存，尽量减少磁盘访问。

对于 InnoDB 表来说，rowid 排序会要求回表多造成磁盘读，因此不会被优先选择。

更快的方法
----------

**覆盖索引**

通过覆盖索引，索引上的信息足够满足查询请求，就不需要再回到主键索引上去取数据，而且因为索引已经是有序的(注意最左原则)，因此也不需要排序就能快速返回。

当然，这里并不是说要为了每个查询能用上覆盖索引，就要把语句中涉及的字段都建上联合索引，毕竟索引还是有维护代价的。这是一个需要权衡的决定。

