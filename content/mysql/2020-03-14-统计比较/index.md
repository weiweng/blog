+++
title="mysql|统计比较"
tags=["mysql"]
categories=["mysql"]
date="2020-03-14T02:58:00+08:00"
summary = '统计比较'
toc=false
+++

count效率比较
-------------

在不同的 MySQL 引擎中，`count(*)`有不同的实现方式。

-	MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 `count(*)` 的时候会直接返回这个数，效率很高；
-	InnoDB 引擎就麻烦了，它执行 `count(*)` 的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。

这里需要注意的是，我们在这里讨论的是没有过滤条件的`count(*)`，如果加了where条件的话，MyISAM 表也是不能返回得这么快的。

### 相关问题

-	**问题** 如果你现在有一个页面经常要显示交易系统的操作记录总数，到底应该怎么办呢？答案是，我们只能自己计数。

-	**方法** 由于`count(*)`的结果准确，但存在性能问题，针对一个经常变动的交易系统，我们如何快速放回技术？考虑用缓存系统保存计数有丢失数据和计数不精确的问题。所以我们把这个计数直接放到数据库里单独的一张计数表，通过事务可以完美解决技术问题。

### count(*)

mysql不会把全部字段取出来，而是专门做了优化，不取值。count(*) 肯定不是 null，按行累加。

### count(1)

InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。

### count(主键)

InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加。

### count(字段)

-	如果这个“字段”是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加；
-	如果这个“字段”定义允许为 null，那么执行的时候，判断到有可能是 null，还要把值取出来再判断一下，不是 null 才累加。

效率
----

`count(字段)<count(主键 id)<count(1)≈count(*)`

